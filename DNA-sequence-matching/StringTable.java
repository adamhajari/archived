package sequence_match;
//STRINGTABLE.JAVA
//A hash table mapping Strings to their positions in the the pattern sequence
//You get to fill in the methods for this part.
//
public class StringTable {
	
	public int m;
	public int intRec;
	public Record table[];
 
 //
 // Create an empty table big enough to hold maxSize records.
 //
 public StringTable(int maxSize) 
 {	
	m=2;
	intRec = 0;
 	table = new Record[2];
 }
 
 public void repopulate()
 {
	 //make a copy of the table
	 Record temp_table[];
	 temp_table = table;
	 //double m
	 m = 2*m;
	 //reset intRec (it will be reincremented in the following for loop)
	 intRec = 0;
	 //resize and repopulate table using the records from temp_table
	 table = new Record[m];
	 for(int i=0; i<m/2; i++){
		 insert(temp_table[i]);
	 }
 }
 
 
 //
 // Insert a Record r into the table.  Return true if
 // successful, false if the table is full.  You shouldn't ever
 // get two insertions with the same key value, but you may
 // simply return false if this happens.
 //
 public boolean insert(Record r) 
 { 
	//define baseHash, h1, and stepHash, h2
	int hashKey = r.intKey;
 	int h1 = baseHash(hashKey);
    int h2 = stepHash(hashKey);
    
    //initial double hash value s=baseHash
    int s = h1;
    int i = 0;
    
    while(table[s]!=null && i<m){
    	if(table[s].intKey==r.intKey) 
    		if(table[s].key.equals(r.key)){
    			return false; //if record already exists return false
     		}
    	//update i and the hash function
     	s = (s+h2)%(m);
     	i++;
     }
     
     if(table[s]==null) table[s] = r;
     else{ 
     	return false; //table is full
     }
    
    //increment intRec
    intRec++;
    if(intRec>=m) repopulate(); //if table is full, double size and repopulate
	return true; 
 }
 
 
 //
 // Delete a Record r from the table.  Note that you'll have to
 // find the record first unless you keep some extra information
 // in the Record structure.
 //
 public void remove(Record r) 
 {
	//define baseHash, h1, and stepHash, h2
	int hashKey = r.intKey;
	int h1 = baseHash(hashKey);
	int h2 = stepHash(hashKey);
	
	//initial double hash value s=baseHash
	int s = h1;
	int i = 0;
	
    while(table[s]!=null && i<m){
     	if(table[s].intKey==hashKey){
     		//if you find the record, set the intKey to -1
     		table[s].intKey=-1;
     	}
     	//update the hash function
     	s = (s+h2)%(m);
     	i++;
     }
 }
 
 
 //
 // Find a record with a key matching the input.  Return the
 // record if it exists, or null if no matching record is found.
 //
 public Record find(String key) 
 {
 	int hashKey = toHashKey(key);
 	int h1 = baseHash(hashKey);
    int h2 = stepHash(hashKey);
    
  //initial hash function value
    int s = h1;
    int i = 0;
    while(table[s]!=null && i<m){
     	if(table[s].intKey==hashKey){
     		if(table[s].key.equals(key)){
     			return table[s]; //if record is found, return it.
     		}
     	}
     	//update i and the hash function
     	s = (s+h2)%(m);
     	i++;
     }
     if(table[s]==null || i>=m){ 
     	return null; //key not found
     }
     else{ 
     	return table[s];
     }
 }
 
 //Print the contents of a table
 public void printTable() 
 {
	 //int filled counts the number of filled slots. empty counts the number of empty slots
	int filled = 0;
	int empty = 0;
 	for (int j = 0; j < m; j++){
 		if (table[j]!=null){
 			System.out.println("slot: "+j+":   positions: "+table[j].positions+":   value: "+table[j].key);
 			filled++;
 		}else{
 			System.out.println("slot: "+j+":   empty");
 			empty++;
 		}
 	}System.out.println("total filled: "+filled+"   total empty: "+empty);
 }
 
 
 ///////////////////////////////////////////////////////////////////////
 
 
 // Convert a String key into an integer that serves as input to hash
 // functions.  This mapping is based on the idea of a linear-congruential
 // pesudorandom number generator, in which successive values r_i are 
 // generated by computing
 //    r_i = ( A * r_(i-1) + B ) mod M
 // A is a large prime number, while B is a small increment thrown in
 // so that we don't just compute successive powers of A mod M.
 //
 // We modify the above generator by perturbing each r_i, adding in
 // the ith character of the string and its offset, to alter the
 // pseudorandom sequence.
 //
 public static int toHashKey(String s)
 {
	int A = 1952786893;
	int B = 367257;
	int v = B;
	
	for (int j = 0; j < s.length(); j++)
	    {
		char c = s.charAt(j);
		v = A * (v + (int) c + j) + B;
	    }
	
	if (v < 0) v = -v;
	return v;
 }
 
 //multiplicative hash functions to be used in the double hash function
 //within each method
 int baseHash(int hashKey)
 {
 	double A = Math.sqrt(3)-1;
 	int h1 = (int)Math.floor(m*(A*hashKey-Math.floor(A*hashKey)));
 	return h1;
 }
 
 //since the table size is a power of 2 stepHash should be odd
 int stepHash(int hashKey)
 {
 	double A = (Math.sqrt(5)-1)/2;
 	int h2 = (int)Math.floor(m*(A*hashKey-Math.floor(A*hashKey)));
 	if(h2%2==0) h2 = h2+1;  //if h2 is even, add 1 and make it odd
 	return h2;
 }
}